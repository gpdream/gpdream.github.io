<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>lucene源码阅读3-flush | 甲鱼的大数据之旅</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="跟着debug走读flush全流程代码">
<meta name="keywords" content="es">
<meta property="og:type" content="article">
<meta property="og:title" content="lucene源码阅读3-flush">
<meta property="og:url" content="https://gpdream.github.io/2018/05/04/es/lucene-3-flush/index.html">
<meta property="og:site_name" content="甲鱼的大数据之旅">
<meta property="og:description" content="跟着debug走读flush全流程代码">
<meta property="og:updated_time" content="2018-05-04T08:43:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lucene源码阅读3-flush">
<meta name="twitter:description" content="跟着debug走读flush全流程代码">
  
    <link rel="alternate" href="/atom.xml" title="甲鱼的大数据之旅" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">甲鱼的大数据之旅</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">从入门到跑路</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://gpdream.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="title-es/lucene-3-flush" class="article article-type-title" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/04/es/lucene-3-flush/" class="article-date">
  <time datetime="2018-05-04T08:13:33.000Z" itemprop="datePublished">2018-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      lucene源码阅读3-flush
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>跟着debug走读flush全流程代码<br><a id="more"></a></p>
<p>lucene在一些数据的写动作的时候，比如insert/update/delete等动作，并不会直接写入到磁盘，而是在内存中生效。然后再由某些条件去触发flush动作，这些动作有addIndexs,forceMerge,forceMergeDeletes,shutdown。还有在Insert和delete之类的动作，超过了LiveIndexWriterConfig.maxBufferedDocs和LiveIndexWriterConfig.ramBufferSizeMB之类的时候都会触发flush动作。当然也可以直接调用flush接口。</p>
<p>索引的flush入口在IndexWriter.flush。或者是上述的一些动作触发。<code>IndexWriter.flush</code>-&gt;<code>IndexWriter.doFLush()</code>.我们就从<code>doFlush()</code>方法开始看.代码看着比较多，但真正做flush动作的内容其实就是<code>docWriter.flushAllThreads();;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">private boolean doFlush(boolean applyAllDeletes) throws IOException &#123;</div><div class="line">   if (tragedy.get() != null) &#123;</div><div class="line">     throw new IllegalStateException(&quot;this writer hit an unrecoverable error; cannot flush&quot;, tragedy.get());</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   doBeforeFlush();</div><div class="line">   testPoint(&quot;startDoFlush&quot;);</div><div class="line">   boolean success = false;</div><div class="line">   try &#123;</div><div class="line"></div><div class="line">     if (infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">       infoStream.message(&quot;IW&quot;, &quot;  start flush: applyAllDeletes=&quot; + applyAllDeletes);</div><div class="line">       infoStream.message(&quot;IW&quot;, &quot;  index before flush &quot; + segString());</div><div class="line">     &#125;</div><div class="line">     boolean anyChanges = false;</div><div class="line">     </div><div class="line">     synchronized (fullFlushLock) &#123;</div><div class="line">       boolean flushSuccess = false;</div><div class="line">       try &#123;</div><div class="line">       //调用docWriter的flushALlThreads做flush动作</div><div class="line">         long seqNo = docWriter.flushAllThreads();</div><div class="line">         if (seqNo &lt; 0) &#123;</div><div class="line">           seqNo = -seqNo;</div><div class="line">           anyChanges = true;</div><div class="line">         &#125; else &#123;</div><div class="line">           anyChanges = false;</div><div class="line">         &#125;</div><div class="line">         if (!anyChanges) &#123;</div><div class="line">           // flushCount is incremented in flushAllThreads</div><div class="line">           flushCount.incrementAndGet();</div><div class="line">         &#125;</div><div class="line">         flushSuccess = true;</div><div class="line">       &#125; finally &#123;</div><div class="line">         docWriter.finishFullFlush(this, flushSuccess);</div><div class="line">         processEvents(false);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     if (applyAllDeletes) &#123;</div><div class="line">       applyAllDeletesAndUpdates();</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     anyChanges |= maybeMerge.getAndSet(false);</div><div class="line">     </div><div class="line">     synchronized(this) &#123;</div><div class="line">       doAfterFlush();</div><div class="line">       success = true;</div><div class="line">       return anyChanges;</div><div class="line">     &#125;</div><div class="line">   &#125; catch (VirtualMachineError tragedy) &#123;</div><div class="line">     tragicEvent(tragedy, &quot;doFlush&quot;);</div><div class="line">     throw tragedy;</div><div class="line">   &#125; finally &#123;</div><div class="line">     if (!success) &#123;</div><div class="line">       if (infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">         infoStream.message(&quot;IW&quot;, &quot;hit exception during flush&quot;);</div><div class="line">       &#125;</div><div class="line">       maybeCloseOnTragicEvent();</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>很显然，直接看<code>DocWriter.flushAllThreads()</code>,这里做的事情，其实就把所有要flush的<code>DocumentsWriterPerThread</code>给拿出来全部轮一遍做<code>doFlush(flushingDWPT)</code>,flushingDWPT是<code>DocumentsWriterPerThread</code>类型，是一个代表索引文档的写线程对象。这个方法里才是做真正的flush。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">long flushAllThreads()</div><div class="line">   throws IOException &#123;</div><div class="line">   final DocumentsWriterDeleteQueue flushingDeleteQueue;</div><div class="line">   if (infoStream.isEnabled(&quot;DW&quot;)) &#123;</div><div class="line">     infoStream.message(&quot;DW&quot;, &quot;startFullFlush&quot;);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   long seqNo;</div><div class="line"></div><div class="line">   synchronized (this) &#123;</div><div class="line">     pendingChangesInCurrentFullFlush = anyChanges();</div><div class="line">     flushingDeleteQueue = deleteQueue;</div><div class="line">     /* Cutover to a new delete queue.  This must be synced on the flush control</div><div class="line">      * otherwise a new DWPT could sneak into the loop with an already flushing</div><div class="line">      * delete queue */</div><div class="line">     seqNo = flushControl.markForFullFlush(); // swaps this.deleteQueue synced on FlushControl</div><div class="line">     assert setFlushingDeleteQueue(flushingDeleteQueue);</div><div class="line">   &#125;</div><div class="line">   assert currentFullFlushDelQueue != null;</div><div class="line">   assert currentFullFlushDelQueue != deleteQueue;</div><div class="line">   </div><div class="line">   boolean anythingFlushed = false;</div><div class="line">   try &#123;</div><div class="line">     DocumentsWriterPerThread flushingDWPT;</div><div class="line">     // Help out with flushing:</div><div class="line">     //把要flush的线程一个个拖出来给轮了</div><div class="line">     while ((flushingDWPT = flushControl.nextPendingFlush()) != null) &#123;</div><div class="line">     //做具体的doFlush</div><div class="line">       anythingFlushed |= doFlush(flushingDWPT);</div><div class="line">     &#125;</div><div class="line">     // If a concurrent flush is still in flight wait for it</div><div class="line">     flushControl.waitForFlush();  </div><div class="line">     if (anythingFlushed == false &amp;&amp; flushingDeleteQueue.anyChanges()) &#123; // apply deletes if we did not flush any document</div><div class="line">       if (infoStream.isEnabled(&quot;DW&quot;)) &#123;</div><div class="line">         infoStream.message(&quot;DW&quot;, Thread.currentThread().getName() + &quot;: flush naked frozen global deletes&quot;);</div><div class="line">       &#125;</div><div class="line">       ticketQueue.addDeletes(flushingDeleteQueue);</div><div class="line">     &#125;</div><div class="line">     ticketQueue.forcePurge(writer);</div><div class="line">     // we can&apos;t assert that we don&apos;t have any tickets in teh queue since we might add a DocumentsWriterDeleteQueue</div><div class="line">     // concurrently if we have very small ram buffers this happens quite frequently</div><div class="line">     assert !flushingDeleteQueue.anyChanges();</div><div class="line">   &#125; finally &#123;</div><div class="line">     assert flushingDeleteQueue == currentFullFlushDelQueue;</div><div class="line">   &#125;</div><div class="line">   if (anythingFlushed) &#123;</div><div class="line">     return -seqNo;</div><div class="line">   &#125; else &#123;</div><div class="line">     return seqNo;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>由此为止，目前的调用链为<code>IndexWriter.doFLush()</code>-&gt;<code>DocWriter.flushAllThreads()</code>,<code>DocWriter.doFlush(flushingDWPT)</code>。贴<code>doFlush(flushingDWPT)的代码</code>。这里做的具体的动作有<code>ticket = ticketQueue.addFlushTicket(flushingDWPT)</code>;ticketQueue被定义为<code>DocumentsWriterFlushQueue</code>，用来同步多个flush线程。其中<code>ticketQueue.addFlushTicket(flushingDWPT)</code>做了<code>flushingDWPT.prepareFlush()</code>，这里是把一些被标记为删除的数据给提前删除掉了。然后做真正的flush动作<code>flushingDWPT.flush()</code>.在flush完成后把情况添加到ticketQueue中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line">private boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException &#123;</div><div class="line">    boolean hasEvents = false;</div><div class="line">    while (flushingDWPT != null) &#123;</div><div class="line">      hasEvents = true;</div><div class="line">      boolean success = false;</div><div class="line">      SegmentFlushTicket ticket = null;</div><div class="line">      try &#123;</div><div class="line">        assert currentFullFlushDelQueue == null</div><div class="line">            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : &quot;expected: &quot;</div><div class="line">            + currentFullFlushDelQueue + &quot;but was: &quot; + flushingDWPT.deleteQueue</div><div class="line">            + &quot; &quot; + flushControl.isFullFlush();</div><div class="line">        /*</div><div class="line">         由于DWPT是并发可能有多个线程同时执行的，所以要保证flush的顺序，在flush segment的时候删除缓存。</div><div class="line">         这是因为当取出一个DWPT的时候会标记一个全局删除掉点，当flush完的时候会删除这个点的缓存。</div><div class="line">         举例有一个flush A启动并冻结全局删除，然后又有一个flush B启动并冻结自A以后所有的全局删除。如果B在A之前完成，我们需要等待A完成，否则B标记的删除可能不会被用于A，会错过被A标记删除的文档</div><div class="line">         */</div><div class="line">        try &#123;</div><div class="line">          // Each flush is assigned a ticket in the order they acquire the ticketQueue lock</div><div class="line">          //这里是做准备工作，让flushingDWPT做准备工作并addTicket到队列中</div><div class="line">          ticket = ticketQueue.addFlushTicket(flushingDWPT);</div><div class="line">          final int flushingDocsInRam = flushingDWPT.getNumDocsInRAM();</div><div class="line">          boolean dwptSuccess = false;</div><div class="line">          try &#123;</div><div class="line">            // 这里是真正的segemnt flush</div><div class="line">            final FlushedSegment newSegment = flushingDWPT.flush();</div><div class="line">            //把新flush进去的segment添加到队列中</div><div class="line">            ticketQueue.addSegment(ticket, newSegment);</div><div class="line">            dwptSuccess = true;</div><div class="line">          &#125; finally &#123;</div><div class="line">            subtractFlushedNumDocs(flushingDocsInRam);</div><div class="line">            if (flushingDWPT.pendingFilesToDelete().isEmpty() == false) &#123;</div><div class="line">              putEvent(new DeleteNewFilesEvent(flushingDWPT.pendingFilesToDelete()));</div><div class="line">              hasEvents = true;</div><div class="line">            &#125;</div><div class="line">            if (dwptSuccess == false) &#123;</div><div class="line">              putEvent(new FlushFailedEvent(flushingDWPT.getSegmentInfo()));</div><div class="line">              hasEvents = true;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          // flush was successful once we reached this point - new seg. has been assigned to the ticket!</div><div class="line">          success = true;</div><div class="line">        &#125; finally &#123;</div><div class="line">          if (!success &amp;&amp; ticket != null) &#123;</div><div class="line">            // In the case of a failure make sure we are making progress and</div><div class="line">            // apply all the deletes since the segment flush failed since the flush</div><div class="line">            // ticket could hold global deletes see FlushTicket#canPublish()</div><div class="line">            ticketQueue.markTicketFailed(ticket);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        /*</div><div class="line">         * Now we are done and try to flush the ticket queue if the head of the</div><div class="line">         * queue has already finished the flush.</div><div class="line">         */</div><div class="line">        if (ticketQueue.getTicketCount() &gt;= perThreadPool.getActiveThreadStateCount()) &#123;</div><div class="line">          // This means there is a backlog: the one</div><div class="line">          // thread in innerPurge can&apos;t keep up with all</div><div class="line">          // other threads flushing segments.  In this case</div><div class="line">          // we forcefully stall the producers.</div><div class="line">          putEvent(ForcedPurgeEvent.INSTANCE);</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">      &#125; finally &#123;</div><div class="line">        flushControl.doAfterFlush(flushingDWPT);</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      //开始flush 下一个</div><div class="line">      flushingDWPT = flushControl.nextPendingFlush();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (hasEvents) &#123;</div><div class="line">      writer.doAfterSegmentFlushed(false, false);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // If deletes alone are consuming &gt; 1/2 our RAM</div><div class="line">    // buffer, force them all to apply now. This is to</div><div class="line">    // prevent too-frequent flushing of a long tail of</div><div class="line">    // tiny segments:</div><div class="line">    final double ramBufferSizeMB = config.getRAMBufferSizeMB();</div><div class="line">    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &amp;&amp;</div><div class="line">        flushControl.getDeleteBytesUsed() &gt; (1024*1024*ramBufferSizeMB/2)) &#123;</div><div class="line">      hasEvents = true;</div><div class="line">      if (applyAllDeletes(deleteQueue) == false) &#123;</div><div class="line">        if (infoStream.isEnabled(&quot;DW&quot;)) &#123;</div><div class="line">          infoStream.message(&quot;DW&quot;, String.format(Locale.ROOT, &quot;force apply deletes after flush bytesUsed=%.1f MB vs ramBuffer=%.1f MB&quot;,</div><div class="line">                                                 flushControl.getDeleteBytesUsed()/(1024.*1024.),</div><div class="line">                                                 ramBufferSizeMB));</div><div class="line">        &#125;</div><div class="line">        putEvent(ApplyDeletesEvent.INSTANCE);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return hasEvents;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>这里是<code>DocumentsWriterPerThread.flush()</code>,初始化了一个<code>SegmentWriteState flushState</code>,<code>flushState</code>中包含了该分片的所有信息，由      <code>consumer.flush(flushState);</code>完成把文件的刷入。下面重点看<code>consumer.flush(flushState)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">//把所有准备好的document 刷到一个新的segment</div><div class="line"> FlushedSegment flush() throws IOException &#123;</div><div class="line">    assert numDocsInRAM &gt; 0;</div><div class="line">    //确保所有被标记为删除的数据在prepareFLush阶段被删除</div><div class="line">    assert deleteSlice.isEmpty() : &quot;all deletes must be applied in prepareFlush&quot;;</div><div class="line">    //设置segmentInfo</div><div class="line">    segmentInfo.setMaxDoc(numDocsInRAM);</div><div class="line">    //初始化一个flushState，里面包含了所有要flush成一个segment的信息，后面consumer会根据这个去做flush</div><div class="line">    final SegmentWriteState flushState = new SegmentWriteState(infoStream, directory, segmentInfo, fieldInfos.finish(),</div><div class="line">        pendingUpdates, new IOContext(new FlushInfo(numDocsInRAM, bytesUsed())));</div><div class="line">    final double startMBUsed = bytesUsed() / 1024. / 1024.;</div><div class="line"></div><div class="line">    // Apply delete-by-docID now (delete-byDocID only</div><div class="line">    // happens when an exception is hit processing that</div><div class="line">    // doc, eg if analyzer has some problem w/ the text):</div><div class="line">    if (pendingUpdates.deleteDocIDs.size() &gt; 0) &#123;</div><div class="line">      flushState.liveDocs = codec.liveDocsFormat().newLiveDocs(numDocsInRAM);</div><div class="line">      for(int delDocID : pendingUpdates.deleteDocIDs) &#123;</div><div class="line">        flushState.liveDocs.clear(delDocID);</div><div class="line">      &#125;</div><div class="line">      flushState.delCountOnFlush = pendingUpdates.deleteDocIDs.size();</div><div class="line">      pendingUpdates.bytesUsed.addAndGet(-pendingUpdates.deleteDocIDs.size() * BufferedUpdates.BYTES_PER_DEL_DOCID);</div><div class="line">      pendingUpdates.deleteDocIDs.clear();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (aborted) &#123;</div><div class="line">      if (infoStream.isEnabled(&quot;DWPT&quot;)) &#123;</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;flush: skip because aborting is set&quot;);</div><div class="line">      &#125;</div><div class="line">      return null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    long t0 = System.nanoTime();</div><div class="line"></div><div class="line">    if (infoStream.isEnabled(&quot;DWPT&quot;)) &#123;</div><div class="line">      infoStream.message(&quot;DWPT&quot;, &quot;flush postings as segment &quot; + flushState.segmentInfo.name + &quot; numDocs=&quot; + numDocsInRAM);</div><div class="line">    &#125;</div><div class="line">    final Sorter.DocMap sortMap;</div><div class="line">    try &#123;</div><div class="line">      sortMap = consumer.flush(flushState);</div><div class="line">      // We clear this here because we already resolved them (private to this segment) when writing postings:</div><div class="line">      pendingUpdates.clearDeleteTerms();</div><div class="line">      segmentInfo.setFiles(new HashSet&lt;&gt;(directory.getCreatedFiles()));</div><div class="line"></div><div class="line">      final SegmentCommitInfo segmentInfoPerCommit = new SegmentCommitInfo(segmentInfo, 0, -1L, -1L, -1L);</div><div class="line">      if (infoStream.isEnabled(&quot;DWPT&quot;)) &#123;</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;new segment has &quot; + (flushState.liveDocs == null ? 0 : flushState.delCountOnFlush) + &quot; deleted docs&quot;);</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;new segment has &quot; +</div><div class="line">            (flushState.fieldInfos.hasVectors() ? &quot;vectors&quot; : &quot;no vectors&quot;) + &quot;; &quot; +</div><div class="line">            (flushState.fieldInfos.hasNorms() ? &quot;norms&quot; : &quot;no norms&quot;) + &quot;; &quot; +</div><div class="line">            (flushState.fieldInfos.hasDocValues() ? &quot;docValues&quot; : &quot;no docValues&quot;) + &quot;; &quot; +</div><div class="line">            (flushState.fieldInfos.hasProx() ? &quot;prox&quot; : &quot;no prox&quot;) + &quot;; &quot; +</div><div class="line">            (flushState.fieldInfos.hasFreq() ? &quot;freqs&quot; : &quot;no freqs&quot;));</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;flushedFiles=&quot; + segmentInfoPerCommit.files());</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;flushed codec=&quot; + codec);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      final BufferedUpdates segmentDeletes;</div><div class="line">      if (pendingUpdates.deleteQueries.isEmpty() &amp;&amp; pendingUpdates.numericUpdates.isEmpty() &amp;&amp; pendingUpdates.binaryUpdates.isEmpty()) &#123;</div><div class="line">        pendingUpdates.clear();</div><div class="line">        segmentDeletes = null;</div><div class="line">      &#125; else &#123;</div><div class="line">        segmentDeletes = pendingUpdates;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (infoStream.isEnabled(&quot;DWPT&quot;)) &#123;</div><div class="line">        final double newSegmentSize = segmentInfoPerCommit.sizeInBytes() / 1024. / 1024.;</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;flushed: segment=&quot; + segmentInfo.name +</div><div class="line">            &quot; ramUsed=&quot; + nf.format(startMBUsed) + &quot; MB&quot; +</div><div class="line">            &quot; newFlushedSize=&quot; + nf.format(newSegmentSize) + &quot; MB&quot; +</div><div class="line">            &quot; docs/MB=&quot; + nf.format(flushState.segmentInfo.maxDoc() / newSegmentSize));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      assert segmentInfo != null;</div><div class="line"></div><div class="line">      FlushedSegment fs = new FlushedSegment(infoStream, segmentInfoPerCommit, flushState.fieldInfos,</div><div class="line">          segmentDeletes, flushState.liveDocs, flushState.delCountOnFlush,</div><div class="line">          sortMap);</div><div class="line">     //合并segment文件      </div><div class="line">      sealFlushedSegment(fs, sortMap);</div><div class="line">      if (infoStream.isEnabled(&quot;DWPT&quot;)) &#123;</div><div class="line">        infoStream.message(&quot;DWPT&quot;, &quot;flush time &quot; + ((System.nanoTime() - t0) / 1000000.0) + &quot; msec&quot;);</div><div class="line">      &#125;</div><div class="line">      return fs;</div><div class="line">    &#125; catch (Throwable t) &#123;</div><div class="line">      onAbortingException(t);</div><div class="line">      throw t;</div><div class="line">    &#125; finally &#123;</div><div class="line">      maybeAbort(&quot;flush&quot;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>DefaultIndexingChain.flush(SegmentWriteState state)</code>是把文件刷入具体的磁盘。这里第一步是<code>writeNorms(state, sortMap);</code>会把segment的codec格式，索引头，字段域信息，字段规范等等信息写入到索引的<code>_32a.nvd</code>和<code>_32a.nvm</code>这两文件中。然后是<code>writeDocValues(state, sortMap);</code>把docValue写入到数据中,再然后是<code>writePoints(state, sortMap);</code>,把ponitValues(取代NumericField)写入，这些东西会被写到.dim文件中；接下来<code>storedFieldsConsumer.finish(maxDoc);storedFieldsConsumer.flush(state, sortMap);</code>会把数据写入到.fdt和.fdx中，这两个文件占了索引存储的大头；<code>termsHash.flush(fieldsToFlush, state, sortMap,normsMergeInstance);</code>把词元信息写入到.tvd和.tvx文件;<code>docWriter.codec.fieldInfosFormat().write(state.directory, state.segmentInfo, &quot;&quot;, state.fieldInfos, IOContext.DEFAULT);</code>把数据写入.fnm程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">  public Sorter.DocMap flush(SegmentWriteState state) throws IOException &#123;</div><div class="line"></div><div class="line">    // NOTE: caller (DocumentsWriterPerThread) handles</div><div class="line">    // aborting on any exception from this method</div><div class="line">    Sorter.DocMap sortMap = maybeSortSegment(state);</div><div class="line">    int maxDoc = state.segmentInfo.maxDoc();</div><div class="line">    long t0 = System.nanoTime();</div><div class="line">    //写入规范，也就是codec格式，索引头，字段域信息，字段规范等等</div><div class="line">    writeNorms(state, sortMap);</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to write norms&quot;);</div><div class="line">    &#125;</div><div class="line">    SegmentReadState readState = new SegmentReadState(state.directory, state.segmentInfo, state.fieldInfos, IOContext.READ, state.segmentSuffix);</div><div class="line">    </div><div class="line">    t0 = System.nanoTime();</div><div class="line">    writeDocValues(state, sortMap);</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to write docValues&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t0 = System.nanoTime();</div><div class="line">    writePoints(state, sortMap);</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to write points&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // it&apos;s possible all docs hit non-aborting exceptions...</div><div class="line">    t0 = System.nanoTime();</div><div class="line">    storedFieldsConsumer.finish(maxDoc);</div><div class="line">    storedFieldsConsumer.flush(state, sortMap);</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to finish stored fields&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    t0 = System.nanoTime();</div><div class="line">    Map&lt;String,TermsHashPerField&gt; fieldsToFlush = new HashMap&lt;&gt;();</div><div class="line">    for (int i=0;i&lt;fieldHash.length;i++) &#123;</div><div class="line">      PerField perField = fieldHash[i];</div><div class="line">      while (perField != null) &#123;</div><div class="line">        if (perField.invertState != null) &#123;</div><div class="line">          fieldsToFlush.put(perField.fieldInfo.name, perField.termsHashPerField);</div><div class="line">        &#125;</div><div class="line">        perField = perField.next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    try (NormsProducer norms = readState.fieldInfos.hasNorms()</div><div class="line">        ? state.segmentInfo.getCodec().normsFormat().normsProducer(readState)</div><div class="line">        : null) &#123;</div><div class="line">      NormsProducer normsMergeInstance = null;</div><div class="line">      if (norms != null) &#123;</div><div class="line">        // Use the merge instance in order to reuse the same IndexInput for all terms</div><div class="line">        normsMergeInstance = norms.getMergeInstance();</div><div class="line">      &#125;</div><div class="line">      //刷入词元</div><div class="line">      termsHash.flush(fieldsToFlush, state, sortMap, normsMergeInstance);</div><div class="line">    &#125;</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to write postings and finish vectors&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Important to save after asking consumer to flush so</div><div class="line">    // consumer can alter the FieldInfo* if necessary.  EG,</div><div class="line">    // FreqProxTermsWriter does this with</div><div class="line">    // FieldInfo.storePayload.</div><div class="line">    t0 = System.nanoTime();</div><div class="line">    docWriter.codec.fieldInfosFormat().write(state.directory, state.segmentInfo, &quot;&quot;, state.fieldInfos, IOContext.DEFAULT);</div><div class="line">    if (docState.infoStream.isEnabled(&quot;IW&quot;)) &#123;</div><div class="line">      docState.infoStream.message(&quot;IW&quot;, ((System.nanoTime()-t0)/1000000) + &quot; msec to write fieldInfos&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return sortMap;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>到此为止，所有的flush动作结束。一个完成的flush流程为<code>IndexWriter.doFLush()</code>-&gt;<code>DocWriter.flushAllThreads()</code>-&gt;<code>DocWriter.doFlush(flushingDWPT)</code>-&gt;<code>DocumentsWriterPerThread.flush()</code>-&gt;<code>DefaultIndexingChain.flush(SegmentWriteState state)</code>。最后的<code>DefaultIndexingChain.flush(SegmentWriteState state)</code>会flush各种数据到lucene的索引文件中。在segment flush完成后，DocumentWriter会尝试合并segment。</p>
<h3 id="索引segment下的文件格式"><a href="#索引segment下的文件格式" class="headerlink" title="索引segment下的文件格式"></a>索引segment下的文件格式</h3><p>直接从网上拿了个文件格式对应的文件</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>后缀</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Segments File</td>
<td>segments.gen, segments_N</td>
<td>存储段文件的提交点信息</td>
</tr>
<tr>
<td>Lock File</td>
<td>write.lock</td>
<td>文件锁，保证任何时刻只有一个线程可以写入索引</td>
</tr>
<tr>
<td>Segment Info</td>
<td>.si</td>
<td>存储每个段文件的元数据信息</td>
</tr>
<tr>
<td>Compound File</td>
<td>.cfs, .cfe</td>
<td>复合索引的文件，在系统上虚拟的一个文件，用于频繁的文件句柄</td>
</tr>
<tr>
<td>Fields</td>
<td>.fnm</td>
<td>存储域文件的信息</td>
</tr>
<tr>
<td>Field Index</td>
<td>.fdx</td>
<td>存储域数据的指针</td>
</tr>
<tr>
<td>Field Data</td>
<td>.fdt</td>
<td>存储所有文档的字段信息</td>
</tr>
<tr>
<td>Term Dictionary</td>
<td>.tim</td>
<td>term字典，存储term信息</td>
</tr>
<tr>
<td>Term Index</td>
<td>.tip</td>
<td>term字典的索引文件</td>
</tr>
<tr>
<td>Frequencies</td>
<td>.frq</td>
<td>词频文件，包含文档列表以及每一个term和其词频</td>
</tr>
<tr>
<td>Positions</td>
<td>.prx</td>
<td>位置信息，存储每个term，在索引中的准确位置</td>
</tr>
<tr>
<td>Norms</td>
<td>.nrm.cfs, .nrm.cfe</td>
<td>存储文档和域的编码长度以及加权因子</td>
</tr>
<tr>
<td>Per-Document Values</td>
<td>.dv.cfs, .dv.cfe</td>
<td>编码除外的额外的打分因素，</td>
</tr>
<tr>
<td>Term Vector Index</td>
<td>.tvx</td>
<td>term向量索引，存储term在文档中的偏移距离</td>
</tr>
<tr>
<td>Term Vector Documents</td>
<td>.tvd</td>
<td>包含每个文档向量的信息</td>
</tr>
<tr>
<td>Term Vector Fields</td>
<td>.tvf</td>
<td>存储filed级别的向量信息</td>
</tr>
<tr>
<td>Deleted Documents</td>
<td>.del</td>
<td>存储索引删除文件的信息</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://gpdream.github.io/2018/05/04/es/lucene-3-flush/" data-id="cjgrpqcau0009pqi9ea34y786" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es/">es</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/05/04/es/lucene-2-core/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          lucene源码阅读2-core部分-创建索引
        
      </div>
    </a>
  
  
    <a href="/2018/05/04/es/lucene-1-dir/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">luene源码目录</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/aliyun/">aliyun</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es/">es</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/greenplum/">greenplum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hadoop/">hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/influxdb/">influxdb</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mycat/">mycat</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/aliyun/" style="font-size: 12.5px;">aliyun</a> <a href="/tags/es/" style="font-size: 17.5px;">es</a> <a href="/tags/greenplum/" style="font-size: 20px;">greenplum</a> <a href="/tags/hadoop/" style="font-size: 12.5px;">hadoop</a> <a href="/tags/influxdb/" style="font-size: 10px;">influxdb</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/mycat/" style="font-size: 15px;">mycat</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/04/es/lucene-2-core/">lucene源码阅读2-core部分-创建索引</a>
          </li>
        
          <li>
            <a href="/2018/05/04/es/lucene-3-flush/">lucene源码阅读3-flush</a>
          </li>
        
          <li>
            <a href="/2018/05/04/es/lucene-1-dir/">luene源码目录</a>
          </li>
        
          <li>
            <a href="/2018/02/09/es/es-intro/">elasticsearch介绍</a>
          </li>
        
          <li>
            <a href="/2017/07/03/influxdb/influxdb-term/">influxdb术语</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 甲鱼<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>